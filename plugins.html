<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plugins</title>
  
  <script type="text/javascript" src="scripts/highlight.js"></script>
  <link rel="stylesheet" href="styles/style.css">
</head>
<body>
  <div id="sidebar" class="interface"><ul><li class="header"><a href="#overview">Overview</a><li class="header"><a href="#installation">Installation</a><li class="header"><a href="#modes">Modes</a><li class="header"><a href="#plugin">Plugin API</a><ul class="sub"><li><a href="#moduleresources">moduleResources </a></li><li><a href="#resourcelist">resourceList </a></li><li><a href="#file">file </a></li><li><a href="#filename">fileName </a></li><li><a href="#module">module </a></li><li><a href="#resource">resource </a></li><li><a href="#method">Method parameters</a></li><li><a href="#lifecycle">Lifecycle Pseudocode</a></li><li><a href="#caches">Caches</a></li></ul></li><li class="header"><a href="#warnings">Warnings</a><li class="header"><a href="#fileutils">FileUtils</a><ul class="sub"><li><a href="#resetcache">resetCache </a></li><li><a href="#resolvepath">resolvePath </a></li><li><a href="#readfilesync">readFileSync </a></li><li><a href="#makerelative">makeRelative </a></li><li><a href="#stat">stat </a></li><li><a href="#readfile">readFile </a></li><li><a href="#readdir">readdir </a></li><li><a href="#ensuredirs">ensureDirs </a></li><li><a href="#writefile">writeFile </a></li><li><a href="#loadresource">loadResource </a></li></ul></li></li></li></li></li></ul></div>
  <div class="container"><div class="page">
    <h1>Plugins</h1>

<h2 id="overview">Overview</h2>

<p>Lumbar may be extended through plugins that can inject or modify the behavior at numerous different
places in the build process.  A chaining pattern is used so each plugin can either return, modify or
replace the response from plugins that are later in the chain.</p>

<h2 id="installation">Installation</h2>

<p>Plugins can be used in 2 ways. The first allows passing configuration options to the plugin
which can be accessed as the first parameter if the plugin exports a function.</p>

<pre><code>module.exports = function(options) {
  return {
    // plugin methods
  };
};</code></pre>

<p>For plugins that do not require instance options, a singleton exports pattern can be used</p>

<pre><code>module.exports = {
  // plugin methods
};</code></pre>

<h2 id="modes">Modes</h2>

<p>A mode is an operating context or filter so that only plugins that are registered for a given mode are
allowed to operate - otherwise they are ignored.</p>

<p>The plugin can contribute new modes (or bind to existing modes) by exporting a <code>mode</code> value which can either
be a string or an array of strings.  Lumber operates with 3 defined modes by default:</p>

<ul><li><strong>scripts</strong>: Compile and copy all javascript artifacts to build</li><li><strong>styles</strong>: Compile and copy all stylus and css artifacts to build</li><li><strong>static</strong>: Copy all static resources to build</li></ul>

<p>Lumbar will iterate a build lifecycle for each unique platform, module and mode combination.  This
allows the plugins to filter build resources and operations to only what is meaningful for their purpose.</p>

<pre><code>module.exports = {
  mode: 'scripts' // operate within the scripts mode along with other core plugins
  mode: ['scripts', 'foo'] // scripts mode and add a new mode called 'foo'
  mode: ['foo', 'all'] // add a new 'foo' mode and also operate under all modes
  // if no mode is defined, the plugin will operate under all modes
}</code></pre>

<p>It is recommended that, unless necessary, a mode be explicitly defined.</p>

<h2 id="plugin">Plugin API</h2>

<p>Plugins primary method of interaction with Lumbar it through the <code>moduleResources</code>, <code>resourceList</code>,
<code>file</code>, <code>module</code>, and <code>resource</code> callbacks.</p>

<p>Each of these callbacks are implemented as a chain,
allowing for a plugin to modify the current context object and determine if subsequent plugins are
allowed to operate, via the <code>next</code> parameter passed to the callback.</p>

<p>Almost all plugin methods are asynchronous and have the same signature - (context, next, complete)</p>

<ul><li>context: provides access to all data that a plugin should need.</li><li>next: the chaining callback used to execute the remaining plugins</li><li>complete: the completion callback</li></ul>

<p>All parameters are described in more detail after the method documentation.</p>

<h3 id="moduleresources">moduleResources <em>moduleResources(context, next, complete)</em></h3>

<p>Called when generating a list of all resources that a given module will need. This method may be
used to add additional content to the module such as the router declaration for router
modules.</p>

<p>The expected return value is an array.  The contents of the array can be whatever is meaningful to the plugin.
Other plugin methods can be used to take action on individual entries in the returned list.</p>

<h4 id="resource">Resource expansion</h4>

<p>Each value in the returned array will be expanded if that value represents a directory structure.
This is done by either using a simple string or using the <code>src</code> attribute.  In this case, every
child directory and file will automatically be added as a resource entry.</p>

<p>For example, if the application structure is:</p>

<pre><code>app
  - lumbar.json
  - files
  --- file1.txt
  --- sub-files
  ----- file2.txt</code></pre>

<p>And a resource entry is returned with the value of</p>

<pre><code>{src: "files", foo: "bar"}</code></pre>

<p>or</p>

<pre><code>"files"</code></pre>

<p>The resource entries will be converted to</p>

<pre><code>[
  {dir: "files", foo: "bar"},
  {src: "files/file1.txt", srcDir: "files", foo: "bar"}
  {dir: "files/sub-files", srcDir: "files", foo: "bar"}
  {src: "files/sub-files/file2.txt", srcDir: "files", foo: "bar"}
]</code></pre>

<p>The existence of <code>srcDir</code> to determine if the resource was auto-generated from a resource entry representing a directory.</p>

<p>Any additional attributes that were provided will be added to all created entries as you can
see with the <code>foo</code> attribute.</p>

<p>Note: the <code>foo</code> attribute would not be present if the resource
entry was just <code>files</code> - just <code>{src: "files", foo: "bar"}</code>.</p>

<h4 id="current">Current behavior</h4>

<p>Without implementing this method, the resources retrieved will be the serialized JSON value referenced by the mode key on the module.</p>

<p>For example, if the plugin has defined a mode called <code>foo</code> and a lumbar.json file of:</p>

<pre><code>{
  "modules": {
    "myModule": {

      "foo": [
        "abc", "def"
      ],

      "bar": [
        "ghi", "jkl"
      ]
    }
  }
}</code></pre>

<p>The resources available to the plugin would be:</p>

<pre><code>["abc", "def"]</code></pre>

<h4 id="example">Example</h4>

<p>If the plugin intends to use the 'bar' value (disregarding the fact that maybe the mode should be 'bar'),
a sample moduleResources would be:</p>

<pre><code>module.exports = {
  moduleResources: function(context, next, complete) {
    complete(undefined, context.module.bar);
  }
}</code></pre>

<p>It is also possible to add to the module resources when multiple plugins operate within the same mode.
Here is an example of the router plugin:</p>

<pre><code>moduleResources: function(context, next, complete) {
  next(function(err, ret) {
    if (err) {
      return complete(err);
    }

    // Generate the router if we have the info for it
    var module = context.module;
    if (module.routes) {
      ret.unshift({ routes: module.routes });
    }

    complete(undefined, ret);
  });</code></pre>

<h3 id="resourcelist">resourceList <em>resourceList(context, next, complete)</em></h3>

<p>Allows plugins to create multiple resources from a single resource. This is called once for each
resource generated from the <code>moduleResources</code> callback.</p>

<p>This is useful for plugins that expand on specific resources.</p>

<p>The expected return value is an array of resource objects. The data associated with these objects may be anything the plugin or other plugins will operate on.</p>

<p>Strings will be treated as file or directory includes as will object that define a <code>src</code> field.
Resources that define a <code>platform</code> or <code>platforms</code> fields will be filtered based on the current platform being executed.</p>

<p>For example, the scope plugin wraps the returned resources add a execution scope.</p>

<pre><code>resourceList: function(context, next, complete) {
  next(function(err, resources) {
    if (err) {
      return complete(err);
    }

    if (context.config.attributes.scope === 'resource'
        &amp;&amp; !context.resource.global
        &amp;&amp; !context.resource.dir) {
      resources.unshift(generator('(function() {\n'));
      resources.push(generator('}).call(this);\n'));
    }
    complete(undefined, resources);
  });
}</code></pre>

<h3 id="file">file <em>file(context, next, complete)</em></h3>

<p>Allows plugins to apply file-level changes to the resources. Called once for each file
generated, just prior to resources being combined. May alter the <code>context.resources</code> field
to change the resource list.</p>

<p>This could be used, for example, to append JSONP callbacks to a file.</p>

<h3 id="filename">fileName <em>fileName(context, next, complete)</em></h3>

<p>Allows for plugins to override the default file name used for output file creation.</p>

<p>The return value should be an object with the following attributes:</p>

<ul><li><strong>path</strong>: the file path relative to the output directory (minus the extension)</li><li><strong>extension</strong>: the file extension</li></ul>

<p>For example, the script plugin uses the platform path and module name to create the file name:</p>

<pre><code>fileName: function(context, next, complete) {
  var name = context.module ? context.module.name : context.package;
  complete(undefined, {path: name, extension: 'js'});
}</code></pre>

<h3 id="module">module <em>module(context, next, complete)</em></h3>

<p>Allow plugins to apply module-level changes to the resources. Called once for each module.
May alter the resource list associated with the module by altering the <code>context.moduleResources</code>
field.</p>

<p>This can be useful for writing resources to the output directory.  For example, this is how the
static-output plugin adds the static files to the output directory:</p>

<pre><code>module: function(context, next, complete) {
  next(function(err) {
    async.forEach(context.moduleResources, function(resource, callback) {
        var fileContext = context.clone();
        fileContext.resource = resource;
        var fileInfo = fu.loadResource(resource, function(err, data) {
          if (err || !data || !data.content) {
            return callback(err);
          }

          fileContext.outputFile(function(callback) {
            var ret = {
              fileName: fileContext.fileName,
              inputs: fileInfo.inputs || [ fileInfo.name ],
              fileConfig: context.fileConfig,
              platform: context.platform,
              package: context.package,
              mode: context.mode
            };

            fu.writeFile(fileContext.fileName, data.content, function(err) {
              callback(err, ret);
            });
          },
          callback);
        });
      },
      complete);
  });
}</code></pre>

<h3 id="resource">resource <em>resource(context, next, complete)</em></h3>

<p>Allows plugins to include content other than direct file references as well as chain resource modifications.</p>

<p>The current resource can be referenced using <code>context.resource</code>.</p>

<p>In general, the plugin should have one of the following return values:</p>

<h4 id="return:">Return: callback function</h4>

<p>This function is used for asynchronous data loading. The callback has the standard <code>(err, data)</code> signature</p>

<ul><li><strong>err</strong> is used to indicate an error</li><li><strong>data</strong> can be a string or buffer representing file contents or a hash with the following values:<ul><li><strong>data</strong>: the string or buffer file contents</li><li><strong>noSeparator</strong>: truthy - adds ';;' separator for when content is known to be validated javascript or css,  Resources that always end in a complete statement should utilize this field.</li><li><strong>inputs</strong>: a list of files that, if in watch mode, impact the generation of this file</li></ul></li></ul>

<p>For example, this is how the async callback function can be used to write "Hello World!"</p>

<pre><code>resource: function(context, next, complete) {
  complete(undefined, function(context, complete) {
    if ( *simple* ) {
      complete(undefined, "Hello World!");
    } else {
      var dependantFiles = [...];
      complete(undefined, {data: "Hello World!", inputs: dependantFiles}
    }
  });
}</code></pre>

<h4 id="return:">Return: An object</h4>

<p>This object should have the following attributes:
<em> <strong>src</strong>: file path relative to the lumbar.json file
</em> <strong>dest</strong>: only applicable for static resources - the destination path relative to the platform
* <strong>sourceFile</strong>: file path that, if in watch mode, should be watched to trigger a rebuild.  This is not needed if src is defined.</p>

<h3 id="method">Method parameters</h3>

<h4 id="context">Context</h4>

<p>Each plugin method is passed a <code>context</code> parameter which describes the entire state of the build
at the point of the call. Plugins are free to modify this structure as they please.</p>

<p>The context is cloned at various times during the lumbar lifecycle so any modifications to the context
can not be guaranteed to exist outside of the plugin method that made the modification.</p>

<ul><li><strong>package</strong> : The name of the package currently being operated on.</li><li><strong>platform</strong> : The name of the platform currently being operated on.</li><li><strong>module</strong> : The module currently being operated on, as defined in the JSON file.</li><li><strong>resource</strong> : The resource currently being operated on, if applicable. Definition depends on plugins.</li><li><strong>moduleResources</strong> : All resources associated with the current module, if available.</li><li><strong>resources</strong> : All resources associated with a file. For non-combined cases this is identical to <code>moduleResources</code></li><li><strong>platformPath</strong> : Path to the output path for the current platform</li><li><strong>options</strong> : Options passed to the lumbar initialize call</li><li><strong>config</strong> : Current lumbar configuration. See <em>config.js</em></li><li><strong>combined</strong> : Truthy if the output content is intended to be combined when possible</li></ul>

<p>Some utility functions are also available:</p>

<ul><li><p><strong>loadResource(resource, callback)</strong>: Async method for retrieving file contents of a resource.</p><ul><li><strong>resource</strong>: the resource that is provided as <code>context.resource</code> in the resource method</li><li><p><strong>callback</strong>: async callback method with the following parameters:</p><ul><li><strong>err</strong>: error if anything went wrong</li><li><p><strong>data</strong>: buffer or what was returned if the resource provided was a function </p></li></ul></li></ul></li><li><p><strong>outputFile(writer, callback)</strong>: write content to a file</p><ul><li><strong>writer</strong>: </li><li><strong>callback</strong>: 
FIXME: Kevin, can you document the parameter usage?</li></ul></li></ul>

<h4 id="next">Next and Complete</h4>

<p>Each plugin is responsible for completing the plugin chain by calling next() or compete().
Next is called to let the other plugins respond while complete is used to stop the plugin
chain and directly return a result.</p>

<p>The complete callback can be provided as a parameter to next if desired but not necessary.</p>

<p>see examples below:</p>

<pre><code>module.exports = {
  moduleResources: function(context, next, complete) {
    if ( *continue with chain* ) {
      next();

    } else if ( *modify plugin result* ) {
      // define a new complete function
      function _complete (err, data) {
        if (err) {
          // something bad happened
          complete(err, data);
        } else {
          data.push("something new");
          complete(undefined, data);
        }
      }
      // call next and override the existing complete function
      next(_complete);

    } else if ( *stop the plugin chain and return something* ) {
      var something = [...];
      complete(undefined, something);

    } else {
      // we're asyncronous - *always* make sure to call next or complete!
      next();
    }
  }
}</code></pre>

<h3 id="lifecycle">Lifecycle Pseudocode</h3>

<p>For an understanding of how these methods work together, see the following <em>extremely simplified</em> pseudocode:</p>

<pre><code>for each defined platform
  for each mode {added by `plugin.mode`}
    for each module in platform {as determined by package}
      resources = `plugin.moduleResources`
      for each resource in resources
        if resource matches `plugin.fileFilter`
          replace/expand resource if it matches a directory
        else
          remove from the list of resources

      for each resource in resources
        replace/flatten resource with `plugin.resourceList`

      call `plugin.module`
      for each resource in resources
        resource = 'plugin.resource'</code></pre>

<h3 id="caches">Caches</h3>

<p>Each context object defines a variety of caches that are reset at specific points through the
build process. This allows plugins to cache any relevant data for specific timeframes. Note
that these objects are shared across all plugins so proper naming conventions should be followed
to prevent conflicts.</p>

<ul><li><strong>configCache</strong> : Reset when the configuration file changes</li><li><strong>fileCache</strong> : Reset when the current file processing completes</li><li><strong>moduleCache</strong> : Reset when the current module processing completes</li></ul>

<h2 id="warnings">Warnings</h2>

<p>As most Lumbar projects are dealing with a large number of files it is quite susceptible to
<strong>EMFILE</strong> exceptions under OSX. The current recovery method for this is to utilize async
methods and retry methods that fail due to this error. A variety of file methods that are
protected from this case have been made available on the <code>lumbar.fileUtil</code> object. It
is recommended that these methods are used whenever possible while dealing with files throughout
the system.</p>

<h2 id="fileutils">FileUtils</h2>

<p>With respect to the previous warning about EMFILE, all file access should be done using fileUtils (fileUtils.js).
This should be accessed from the context using the <code>fileUtil</code> key.  This wraps much of the functionality of <code>fs</code>
with handling of EMFILE errors.</p>

<p>FileUtils also caches files that are referenced to optimize build time.</p>

<h3 id="resetcache">resetCache <em>resetCache(path)</em></h3>

<p>Clear all cached file content</p>

<ul><li><strong>path</strong>: Clear all or clear for a specific path. falsy or missing input for path will clear all.</li></ul>

<h3 id="resolvepath">resolvePath <em>resolvePath(path)</em></h3>

<p>Return a file path that, if relative, is appropriatly qualitied with the build output path based on the 'lookupPath'</p>

<ul><li><strong>path</strong>: the file path</li></ul>

<h3 id="readfilesync">readFileSync <em>readFileSync(path)</em></h3>

<p>Same as fs.readFileSync but uses <code>resolvePath</code></p>

<ul><li><strong>path</strong>: the file path</li></ul>

<h3 id="makerelative">makeRelative <em>makeRelative(path)</em></h3>

<p>The opposite of resolvePath.  This will remove the lookup path if the path has that as a prefix.</p>

<h3 id="stat">stat <em>stat(file, callback)</em></h3>

<p>Same as fs.stat but with EMFILE handling</p>

<ul><li><strong>file</strong>: the file path</li><li><strong>callback</strong>: the asynchronous callback</li></ul>

<h3 id="readfile">readFile <em>readFile(file, callback)</em></h3>

<p>Same as fs.readFile cacheing.  A buffer is returned.</p>

<ul><li><strong>file</strong>: the file path</li><li><strong>callback</strong>: the asynchronous callback</li></ul>

<h3 id="readdir">readdir <em>readdir(dir, callback)</em></h3>

<p>same as fs.readdir with cacheing.</p>

<ul><li><strong>dir</strong>: the directory path</li><li><strong>callback</strong>: the asynchronous callback</li></ul>

<h3 id="ensuredirs">ensureDirs <em>ensureDirs(pathname, callback)</em></h3>

<p>Ensure that the parent directories for the provided file path exist and create otherwise.</p>

<ul><li><strong>pathname</strong>: the file path</li><li><strong>callback</strong>: the asynchronous callback</li></ul>

<h3 id="writefile">writeFile <em>writeFile(file, data, callback)</em></h3>

<p>Same as fs.writefile but will also ensure directories, cache file contents, and handle EMFILE errors gracefully.</p>

<ul><li><strong>file</strong>: the file path</li><li><strong>data</strong>: the file contents</li><li><strong>callback</strong>: the asynchronous callback</li></ul>

<h3 id="loadresource">loadResource <em>loadResource(resource, callback)</em></h3>

<p>Specifically designed to load a lumbar resource (see the lumbar API <code>resource</code> method).</p>

<ul><li><strong>resource</strong>: the lumbar resource</li><li><strong>callback</strong>: the asynchronous callback</li></ul>
  </div></div>
  <a href="http://github.com/walmartlabs/lumbar">
    <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://a248.e.akamai.net/assets.github.com/img/71eeaab9d563c2b3c590319b398dd35683265e85/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub">
  </a>
</body>
</html>
